import java.io.*;
import java.lang.Process;
import java.nio.file.Files;
import java.util.*;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import edu.cmu.sphinx.api.Configuration;
import edu.cmu.sphinx.api.SpeechResult;
import edu.cmu.sphinx.api.StreamSpeechRecognizer;
import edu.cmu.sphinx.result.WordResult;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

public class Transcribe {
   private final static String OUTPUT_DIR = "output";
   private final static int NUM_TOPICS = 10;

   public static void main(String[] args) throws Exception {
      Configuration configuration = new Configuration();
      final Scanner scanner = new Scanner(System.in);
      String outputFile;

      // Set path to acoustic model, dictionary, and language model, then initialize recognizer.
      configuration.setAcousticModelPath("resource:/edu/cmu/sphinx/models/en-us/en-us");
      configuration.setDictionaryPath("resource:/edu/cmu/sphinx/models/en-us/cmudict-en-us.dict");
      configuration.setLanguageModelPath("resource:/edu/cmu/sphinx/models/en-us/en-us.lm.bin");

      StreamSpeechRecognizer recognizer = new StreamSpeechRecognizer(configuration);

      System.out.println("Welcome to the Lexure audio file transcriber!\n");

      createOutputDir();

      // CLI
      while (true) {
         // Setup input
         String fname = null;
         while (true) {
            try {
               fname = prompt(scanner, "Please input the file name to be transcribed: ");
               System.out.printf("Input File: %s", fname);
               InputStream stream = new FileInputStream(new File(fname));
               recognizer.startRecognition(stream);
               break;
            } catch (FileNotFoundException e) {
               System.out.printf("File %s not found. Please enter another filename to try or type quit to quit. \n", fname);
            }
         }
         SpeechResult result;

         // Setup output
         PrintWriter writer;

         while (true) {
            try {
               fname = prompt(scanner, "Please input the file name to be used for output relative to the output folder: ");
               System.out.printf("Output File: %s\n\n", fname);
               outputFile = fname;
               writer = new PrintWriter(OUTPUT_DIR + "/" + fname, "UTF-8");
               break;
            } catch (FileNotFoundException e) {
               System.err.printf("Unable to open %s. Please enter another filename to try. \n", fname);
            }
         }

         System.out.println("Lexure now transcribing input file...\n");

         while ((result = recognizer.getResult()) != null) {
            System.out.format("Hypothesis: %s\n", result.getHypothesis());

            // Get individual words and their times
            for (WordResult r : result.getWords()) {
               System.out.println(r);
            }

            // Write to output file
            writer.println(result.getHypothesis());
         }

         writer.close();
         recognizer.stopRecognition();

         System.out.println("Transcription complete! Beginning topic modelling...\n");

         copyToMalletDir(outputFile);
         topicModelling();
         processXMLTopicCluster();
      }
   }

   public static String prompt(Scanner console, String s) {
      System.out.print(s);
      String out = console.nextLine();
      if (out.equalsIgnoreCase("quit")) {
         System.out.println("\nThank you for using the Lexure audio file transcriber.");
         System.exit(0);
      }
      return out;
   }

   public static void createOutputDir() {
      File directory = new File(OUTPUT_DIR);

      // Create new directory for transcriptions
      if (!directory.exists()) {
         try {
            directory.mkdir();
         } catch (SecurityException se) {
            System.err.printf("Unable to create output directory %s.\n", OUTPUT_DIR);
         }
      }
   }

   public static void copyToMalletDir(String outputFile) {
      final File source = new File(OUTPUT_DIR + "/" + outputFile),
              dest = new File("./mallet-2.0.8/input/" + outputFile);

      // Copy text file (generated by transcribing wav file) to mallet directory
      try {
         Files.copy(source.toPath(), dest.toPath(), REPLACE_EXISTING);
      } catch (IOException e) {
         e.printStackTrace();

         System.exit(1);
      }
   }

   public static void topicModelling() {
      List<String> modelling = Arrays.asList(
              "./mallet-2.0.8/topicModelling.sh",
              "mallet-2.0.8/input",
              "out.mallet");
      String line;

      // Execute bash script that does topic modeling
      try {
         Process p = new ProcessBuilder(modelling).start();
         BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
         BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));

         System.out.println("Script output:");

         // Print out script standard output as if running in terminal
         while ((line = stdInput.readLine()) != null) {
            System.out.println(line);
         }

         // Print out script standard error
         while ((line = stdError.readLine()) != null) {
            System.out.println(line);
         }

         p.waitFor();
      } catch (IOException e) {
         e.printStackTrace();

         System.exit(1);
      } catch (InterruptedException e) {
         e.printStackTrace();

         System.exit(1);
      }

      System.out.println("Topic modelling complete!\n");
   }

   public static class TopicInformation implements Comparable<TopicInformation> {
      int id;
      double alpha;
      String mostFrequent;

      public TopicInformation(int id, double alpha, String mostFrequent) {
         this.id = id;
         this.alpha = alpha;
         this.mostFrequent = mostFrequent;
      }

      public int compareTo(TopicInformation ti) {
         // Sort alpha descending
         return this.alpha < ti.alpha ? 1 : -1;

         // Sort alpha ascending
         //return this.alpha < ti.alpha ? -1 : 1;
      }

      public static Comparator<TopicInformation> TIComparator = new Comparator<TopicInformation>() {
         @Override
         public int compare(TopicInformation ti1, TopicInformation ti2) {
            return ti1.compareTo(ti2);
         }
      };
   }

   public static void processXMLTopicCluster() {
      try {
         File file = new File("mallet-2.0.8/output/topicReport.xml");

         // Create XML parser
         DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
         DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
         Document doc = dBuilder.parse(file);
         doc.getDocumentElement().normalize();

         // Get a topic elements under topicModel
         NodeList topicList = doc.getElementsByTagName("topic");

         // Topic # refers to the cluster of words it belongs to
         System.out.println("| TOPIC # |   ALPHA   | MOST FREQUENT WORD |");

         List<TopicInformation> topicInfoList = new ArrayList<>();

         // Initialize topicInfoList, each containing id, alpha, and most frequent word
         for (int index = 0; index < NUM_TOPICS; index++) {
            Node topicNode = topicList.item(index);

            if (topicNode.getNodeType() == Node.ELEMENT_NODE) {
               Element topic = (Element)topicNode;

               TopicInformation temp = new TopicInformation(index,
                       Double.valueOf(topic.getAttribute("alpha")),
                       topic.getElementsByTagName("word").item(0).getTextContent());
               topicInfoList.add(temp);
            }
         }

         // Sort most frequent word of each cluster by its alpha, descending
         topicInfoList.sort(TopicInformation.TIComparator);

         for (int index = 0; index < NUM_TOPICS; index++) {
            TopicInformation info = topicInfoList.get(index);

            System.out.printf("| %7d | %2.7f | %-18s |\n", info.id, info.alpha, info.mostFrequent);
         }
      } catch (Exception e) {
         e.printStackTrace();
      }

   }
}